<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mirror Mirror</title>
<!-- FOSS Font: "Press Start 2P" -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<!-- Supabase Client -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
/*
Mirror Mirror - v6.1 (UI/UX & Bugfix Update)
----------------------------------------------------------------
- FIXED: Duplicate score/chain display on certain screen sizes by synchronizing HUD logic.
- ADDED: Tabbed interface for start and game-over screens to de-clutter the UI and improve visibility.
- RE-ORGANIZED: UI elements into logical tabs (Play/Results, Scores, Options).
*/
    <button class="theme-menu-btn hidden" id="themeMenuBtn" title="Change Theme">üé®</button>

    <canvas id="gameCanvas"></canvas>
    
    <div id="startOverlay" class="overlay">
        <h1 id="startTitle">
            <span class="title-main">Mirror</span>
            <span class="title-mirrored">Mirror</span>
        </h1>

        <div class="tab-nav">
            <button class="tab-link active" data-tab="play">Play</button>
            <button class="tab-link" data-tab="leaderboard">Scores</button>
            <button class="tab-link" data-tab="options">Options</button>
        </div>

        <!-- Play Tab -->
        <div class="tab-panel active" data-tab-panel="play">
            <p id="startDesc">Control the light character. Dark character mirrors your moves. Eat matching food. Avoid everything else.</p>
            <div class="player-setup">
                <h3>Player Setup</h3>
                <input type="text" class="player-name-input" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                <div class="avatar-selector">
                    <div class="avatar-option selected" data-avatar="cat">üê±</div>
                    <div class="avatar-option" data-avatar="monkey">üêµ</div>
                    <div class="avatar-option" data-avatar="dog">üê∂</div>
                    <div class="avatar-option" data-avatar="dino">ü¶ï</div>
                    <div class="avatar-option" data-avatar="bear">üêª</div>
                </div>
            </div>
            <p id="startInstruction" class="start-instruction">TAP TO BEGIN</p>
        </div>

        <!-- Leaderboard Tab -->
        <div class="tab-panel" data-tab-panel="leaderboard">
            <div class="leaderboard">
                <h3>Global Leaderboard</h3>
                <div class="leaderboard-list" id="startLeaderboard">
                    <div class="leaderboard-loading">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Options Tab -->
        <div class="tab-panel" data-tab-panel="options">
            <div class="theme-selector">
                <span>Theme:</span>
            </div>
        </div>
    </div>

    <div id="gameOverlay" class="overlay hidden">
        <h1>GAME OVER</h1>
        
        <div class="tab-nav">
            <button class="tab-link active" data-tab="results">Results</button>
            <button class="tab-link" data-tab="leaderboard">Scores</button>
            <button class="tab-link" data-tab="options">Options</button>
        </div>

        <!-- Results Tab -->
        <div class="tab-panel active" data-tab-panel="results">
            <div class="score-group">
                <p><span>FINAL SCORE</span> <strong id="finalScore">0</strong></p>
                <p><span>SESSION HIGH</span> <strong id="sessionHighScoreVal">0</strong></p>
                <p id="sessionHighMessage" class="hidden celebration-text">NEW SESSION HIGH!</p>
                <p><span>ALL-TIME HIGH</span> <strong id="allTimeHighScoreVal">0</strong></p>
                <p id="allTimeHighMessage" class="hidden celebration-text">NEW ALL-TIME HIGH!</p>
            </div>
            <hr class="divider">
            <div class="stats-group">
                <p><span>HIGHEST CHAIN</span> <strong id="highestChainVal">0</strong></p>
                <p><span>FOOD EATEN</span> <strong id="nodesAbsorbed">0</strong></p>
                <p><span>TIME SURVIVED</span> <strong id="timeSurvived">0s</strong></p>
            </div>
            <button id="submitScoreButton" class="hidden">Submit to Leaderboard</button>
            <button id="restartButton">Play Again</button>
        </div>

        <!-- Leaderboard Tab -->
        <div class="tab-panel" data-tab-panel="leaderboard">
             <div class="leaderboard">
                <h3>Global Leaderboard</h3>
                <div class="leaderboard-list" id="gameOverLeaderboard">
                    <div class="leaderboard-loading">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Options Tab -->
        <div class="tab-panel" data-tab-panel="options">
            <div class="theme-selector">
                <span>Theme:</span>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Supabase Configuration ---
    const SUPABASE_URL = 'https://deitpndwzsfuxmeuxihc.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRlaXRwbmR3enNmdXhtZXV4aWhjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4NjY2MjcsImV4cCI6MjA2NTQ0MjYyN30.UpIpd5jk2Mb-3No1_MFiLH37pBb-t1iFJSjDxTv-5lw';
    
    // Initialize Supabase client
    let supabase = null;
    if (SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY_HERE') {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }

    // --- Canvas and Context Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.querySelector('.game-container');

    // --- Platform Detection ---
    const isMobile = () => ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    // --- Player Data ---
    let playerName = '';
    let selectedAvatar = 'cat';
    const avatarEmojis = {
        cat: 'üê±',
        monkey: 'üêµ',
        dog: 'üê∂',
        dino: 'ü¶ï',
        bear: 'üêª'
    };

    // Load saved player data
    function loadPlayerData() {
        try {
            playerName = localStorage.getItem('mirrorMirrorPlayerName') || '';
            selectedAvatar = localStorage.getItem('mirrorMirrorPlayerAvatar') || 'cat';
            
            if (playerName) {
                document.getElementById('playerNameInput').value = playerName;
            }
            
            // Update avatar selection
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.classList.toggle('selected', option.dataset.avatar === selectedAvatar);
            });
        } catch (e) {
            console.warn('Could not load player data:', e);
        }
    }

    function savePlayerData() {
        try {
            localStorage.setItem('mirrorMirrorPlayerName', playerName);
            localStorage.setItem('mirrorMirrorPlayerAvatar', selectedAvatar);
        } catch (e) {
            console.warn('Could not save player data:', e);
        }
    }

    // --- Leaderboard Functions ---
    async function loadLeaderboard(container) {
        if (!supabase) {
            container.innerHTML = '<div class="leaderboard-loading">Leaderboard unavailable</div>';
            return;
        }

        try {
            const { data, error } = await supabase
                .from('leaderboard')
                .select('player_name, score, avatar_style')
                .order('score', { ascending: false })
                .limit(10);

            if (error) throw error;

            if (data.length === 0) {
                container.innerHTML = '<div class="leaderboard-loading">No scores yet!</div>';
                return;
            }

            let html = '';
            data.forEach((entry, index) => {
                const emoji = avatarEmojis[entry.avatar_style] || 'üê±';
                html += `
                    <div class="leaderboard-entry">
                        <span class="leaderboard-rank">#${index + 1}</span>
                        <span class="leaderboard-name">${emoji} ${entry.player_name}</span>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>
                `;
            });
            container.innerHTML = html;
        } catch (error) {
            console.error('Error loading leaderboard:', error);
            container.innerHTML = '<div class="leaderboard-loading">Failed to load</div>';
        }
    }

    async function submitScore(name, score, avatar) {
        if (!supabase || !name.trim() || score <= 0) return false;

        try {
            const { error } = await supabase
                .from('leaderboard')
                .insert([
                    {
                        player_name: name.trim(),
                        score: score,
                        avatar_style: avatar
                    }
                ]);

            if (error) throw error;
            return true;
        } catch (error) {
            console.error('Error submitting score:', error);
            return false;
        }
    }

    // --- ENHANCED THEME SYSTEM - 20 REFINED DUAL-TONE THEMES ---
    const themes = {
        'ClassicBlue': { name: 'Classic Blue', '--bg-color': '#1a1a2e', '--light-color': '#4da6ff', '--barrier-color': '#3d8bdb' },
        'ForestGreen': { name: 'Forest Green', '--bg-color': '#1a2e1a', '--light-color': '#66cc66', '--barrier-color': '#52a352' },
        'WarmOrange': { name: 'Warm Orange', '--bg-color': '#2e1f1a', '--light-color': '#ff9966', '--barrier-color': '#db7a52' },
        'DeepPurple': { name: 'Deep Purple', '--bg-color': '#2e1a2e', '--light-color': '#cc66ff', '--barrier-color': '#a352db' },
        'OceanTeal': { name: 'Ocean Teal', '--bg-color': '#1a2e2e', '--light-color': '#66ffcc', '--barrier-color': '#52dba3' },
        'SunsetRed': { name: 'Sunset Red', '--bg-color': '#2e1a1a', '--light-color': '#ff6666', '--barrier-color': '#db5252' },
        'GoldenYellow': { name: 'Golden Yellow', '--bg-color': '#2e2e1a', '--light-color': '#ffcc66', '--barrier-color': '#dba352' },
        'SkyBlue': { name: 'Sky Blue', '--bg-color': '#1a1f2e', '--light-color': '#66ccff', '--barrier-color': '#52a3db' },
        'MintGreen': { name: 'Mint Green', '--bg-color': '#1a2e1f', '--light-color': '#66ffcc', '--barrier-color': '#52dba3' },
        'CoralPink': { name: 'Coral Pink', '--bg-color': '#2e1a1f', '--light-color': '#ff66cc', '--barrier-color': '#db52a3' },
        'LavenderPurple': { name: 'Lavender Purple', '--bg-color': '#1f1a2e', '--light-color': '#cc66ff', '--barrier-color': '#a352db' },
        'AquaMarine': { name: 'Aqua Marine', '--bg-color': '#1a2e24', '--light-color': '#66ffd9', '--barrier-color': '#52dbad' },
        'RoseGold': { name: 'Rose Gold', '--bg-color': '#2e1f1a', '--light-color': '#ffb366', '--barrier-color': '#db9052' },
        'ElectricBlue': { name: 'Electric Blue', '--bg-color': '#0f0f1a', '--light-color': '#3399ff', '--barrier-color': '#2980db' },
        'NeonGreen': { name: 'Neon Green', '--bg-color': '#0f1a0f', '--light-color': '#33ff66', '--barrier-color': '#29db52' },
        'HotPink': { name: 'Hot Pink', '--bg-color': '#1a0f1a', '--light-color': '#ff3399', '--barrier-color': '#db2980' },
        'CyberOrange': { name: 'Cyber Orange', '--bg-color': '#1a150f', '--light-color': '#ff6633', '--barrier-color': '#db5229' },
        'DeepTeal': { name: 'Deep Teal', '--bg-color': '#0f1a1a', '--light-color': '#33ffcc', '--barrier-color': '#29dba3' },
        'VoidPurple': { name: 'Void Purple', '--bg-color': '#0f0a1a', '--light-color': '#9933ff', '--barrier-color': '#8029db' },
        'GoldenSun': { name: 'Golden Sun', '--bg-color': '#1a1a0f', '--light-color': '#ffcc33', '--barrier-color': '#dba329' }
    };
    let currentTheme = 'ClassicBlue';
    const LOCAL_STORAGE_KEY_THEME = 'mirrorMirrorTheme';

    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) return;
        currentTheme = themeName;
        const root = document.documentElement;
        for (const [key, value] of Object.entries(theme)) {
            if (key !== 'name') {
                root.style.setProperty(key, value);
                // Set barrier blink color as slightly brighter version
                if (key === '--light-color') {
                    root.style.setProperty('--barrier-blink-color', value);
                }
            }
        }
        
        // Update theme button active state
        document.querySelectorAll('.theme-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });
        try { localStorage.setItem(LOCAL_STORAGE_KEY_THEME, themeName); } catch (e) { console.warn("Could not save theme.", e); }
    }

    function createThemeSelector() {
        const containers = document.querySelectorAll('.theme-selector');
        containers.forEach(container => {
            // Clear existing buttons
            const existingButtons = container.querySelectorAll('.theme-button');
            existingButtons.forEach(btn => btn.remove());
            
            Object.entries(themes).forEach(([key, theme]) => {
                const btn = document.createElement('button');
                btn.className = 'theme-button';
                btn.dataset.theme = key;
                btn.title = theme.name;
                btn.style.background = `linear-gradient(45deg, ${theme['--bg-color']} 30%, ${theme['--light-color']} 70%)`;
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    applyTheme(e.target.dataset.theme);
                });
                container.appendChild(btn);
            });
        });
    }
    
    // --- NEW: Unified Game Configuration with Fixed Coordinates ---
    const GAME_CONFIG = {
        LOGICAL_WIDTH: 1024,
        LOGICAL_HEIGHT: 768,
        CAT_RADIUS: 30,
        FOOD_RADIUS: 15,
        FOOD_SPAWN_INTERVAL_MS: 1500,
        MIN_FOOD_SPAWN_INTERVAL_MS: 300, 
        FOOD_SPAWN_INTERVAL_DECREMENT_PER_SCORE: 10,
        SCORE_FOR_BARRIERS: 100, 
        BARRIER_LINE_WIDTH: 8,
        BARRIER_COLLISION_TOLERANCE: 8,
        SCORE_PER_FOOD: 10, 
        CHAIN_RESET_THRESHOLD_MS: 5000,
        INITIAL_BARRIER_COUNT: 1, 
        MAX_BARRIER_COUNT: 5,
        BARRIER_MIN_LENGTH: 150,
        BARRIER_MAX_LENGTH_FACTOR: 0.4,
        SAFE_DISTANCE_FROM_CATS: 150,
        BARRIER_INCREMENT_SCORE: 150,
        GAME_OVER_EXPLOSION_RADIUS: 100,
        HUD_FONT_SIZE: 24,
        HUD_MARGIN_X: 25,
        HUD_MARGIN_Y: 40
    };

    // --- Game State & Variables ---
    let isGameStarted = false, isGameOver = false, isAnimatingGameOver = false;
    let animationFrameId, score = 0, chainMultiplier = 1, highestChainInGame = 0, nodesAbsorbedCount = 0;
    let startTime = 0, gameDuration = 0, gameOverAnimationStartTime = 0;
    let gameOverAnimationInfo = { x: 0, y: 0 };
    let barrierBlinkPhase = 0;
    const LOCAL_STORAGE_KEY_ALL_TIME_HIGH = 'mirrorMirrorAllTimeHigh';
    let allTimeHighScore = 0, sessionHighScore = 0;
    let barrierWarningShown = false;
    let isGamePaused = false;
    let scoreSubmitted = false;
    
    // Particle System
    const particles = [];
    
    // Chain timer pause management
    let chainTimerStartTime = 0, chainTimerDuration = 0, chainTimerWasPaused = false;
    
    // Touch gesture handling for overlays
    let overlayTouchStartY = 0;
    let overlayTouchStartTime = 0;
    let overlayScrolling = false;
    
    // FPS Control
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS;
    let lastFrameTime = 0;
    let deltaAccumulator = 0;

    // --- Game Objects ---
    const lightcat = { x: 0, y: 0, radius: GAME_CONFIG.CAT_RADIUS };
    const darkcat = { x: 0, y: 0, radius: GAME_CONFIG.CAT_RADIUS };
    const foods = [], barriers = [];
    let lastFoodSpawnTime = 0, currentSpawnInterval, barriersEnabled = false;
    let lastFoodAbsorbedTime = 0, chainResetTimer;
    
    // --- UI Element Selectors ---
    const hudScore = document.querySelector('.hud-score'), hudChain = document.querySelector('.hud-chain');
    const startOverlay = document.getElementById('startOverlay'), gameOverlay = document.getElementById('gameOverlay');
    const startDesc = document.getElementById('startDesc'), startInstruction = document.getElementById('startInstruction');
    const finalScoreSpan = document.getElementById('finalScore'), highestChainValSpan = document.getElementById('highestChainVal');
    const nodesAbsorbedSpan = document.getElementById('nodesAbsorbed'), timeSurvivedSpan = document.getElementById('timeSurvived');
    const restartButton = document.getElementById('restartButton'), submitScoreButton = document.getElementById('submitScoreButton');
    const sessionHighMessage = document.getElementById('sessionHighMessage'), allTimeHighMessage = document.getElementById('allTimeHighMessage');
    const sessionHighScoreValSpan = document.getElementById('sessionHighScoreVal'), allTimeHighScoreValSpan = document.getElementById('allTimeHighScoreVal');
    const themeMenuBtn = document.getElementById('themeMenuBtn');
    const playerNameInput = document.getElementById('playerNameInput');
    const startLeaderboard = document.getElementById('startLeaderboard');
    const gameOverLeaderboard = document.getElementById('gameOverLeaderboard');
    
    // --- Collision Detection ---
    function checkCircleCollision(c1, c2) { 
        const dx = c1.x - c2.x, dy = c1.y - c2.y;
        return (dx * dx + dy * dy) < (c1.radius + c2.radius) ** 2;
    }
    function checkLineCircleCollision(line, circle) {
        const { x1, y1, x2, y2 } = line; const { x, y, radius } = circle;
        const r = radius + GAME_CONFIG.BARRIER_COLLISION_TOLERANCE;
        const len_sq = (x2 - x1) ** 2 + (y2 - y1) ** 2;
        if (len_sq === 0) return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2) < r;
        let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / len_sq;
        t = Math.max(0, Math.min(1, t));
        const closestX = x1 + t * (x2 - x1), closestY = y1 + t * (y2 - y1);
        return ((x - closestX) ** 2 + (y - closestY) ** 2) < r * r;
    }
    function isLineTooCloseToCats(x1, y1, x2, y2) {
        const safeDistance = GAME_CONFIG.SAFE_DISTANCE_FROM_CATS;
        const line = { x1, y1, x2, y2 };
        const lightCheck = { x: lightcat.x, y: lightcat.y, radius: safeDistance };
        const darkCheck = { x: darkcat.x, y: darkcat.y, radius: safeDistance };
        return checkLineCircleCollision(line, lightCheck) || checkLineCircleCollision(line, darkCheck);
    }

    // --- Warning system ---
    function showBarrierWarning() {
        if (barrierWarningShown) return;
        barrierWarningShown = true;
        
        const warningOverlay = document.createElement('div');
        warningOverlay.className = 'warning-overlay';
        warningOverlay.innerHTML = '<div class="warning-text">barriers incoming!</div>';
        gameContainer.appendChild(warningOverlay);
        
        setTimeout(() => {
            if (warningOverlay.parentNode) {
                warningOverlay.remove();
            }
        }, 1000);
    }

    // --- NEW: Tab Setup ---
    function setupTabs() {
        document.querySelectorAll('.overlay').forEach(overlay => {
            const tabLinks = overlay.querySelectorAll('.tab-link');
            const tabPanels = overlay.querySelectorAll('.tab-panel');

            if (tabLinks.length === 0) return;

            tabLinks.forEach(link => {
                link.addEventListener('click', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const tabId = link.dataset.tab;
                    
                    tabLinks.forEach(l => l.classList.remove('active'));
                    tabPanels.forEach(p => p.classList.remove('active'));
                    
                    link.classList.add('active');
                    overlay.querySelector(`.tab-panel[data-tab-panel="${tabId}"]`).classList.add('active');
                });
            });
        });
    }
    
    // --- Initialization ---
    function init() {
        canvas.width = GAME_CONFIG.LOGICAL_WIDTH;
        canvas.height = GAME_CONFIG.LOGICAL_HEIGHT;
        ctx.imageSmoothingEnabled = false; 
        
        startDesc.innerHTML = "Use your mouse or touch to control the light character.<br>The dark character mirrors your every move.";
        startInstruction.textContent = "CLICK / TAP TO BEGIN";
        
        setupPlayerInputs();
        setupTabs(); // Initialize the new tab system
        
        // Setup overlay event handling
        if (isMobile()) {
            setupMobileTouchHandling();
        } else {
            startOverlay.addEventListener('click', handleOverlayClick);
            gameOverlay.addEventListener('click', handleOverlayClick);
        }
        
        // NEW: Unified Pointer Input
        canvas.addEventListener('pointerdown', handlePointerMove, { passive: false });
        canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
        window.addEventListener('keydown', handleKeyDown);
        
        createThemeSelector();
        const savedTheme = localStorage.getItem(LOCAL_STORAGE_KEY_THEME);
        applyTheme(savedTheme && themes[savedTheme] ? savedTheme : 'ClassicBlue');

        restartButton.addEventListener('click', (e) => {
            e.stopPropagation(); e.preventDefault();
            startGame();
        }); 

        submitScoreButton.addEventListener('click', handleSubmitScore);

        themeMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation(); e.preventDefault();
            pauseGame();
        });

        loadPlayerData();
        loadHighScores(); 
        loadLeaderboard(startLeaderboard);
        showStartScreen();
        
        window.addEventListener('resize', draw); // Redraw on resize to prevent artifacts
    }

    // --- Mobile Overlay Touch Handling ---
    function setupMobileTouchHandling() {
        [startOverlay, gameOverlay].forEach(overlay => {
            overlay.addEventListener('touchstart', (e) => {
                if (e.target.closest('.tab-link, .theme-button, .avatar-option, .leaderboard-list')) return;
                const touch = e.touches[0];
                overlayTouchStartY = touch.clientY;
                overlayTouchStartTime = Date.now();
                overlayScrolling = false;
            }, { passive: true });

            overlay.addEventListener('touchmove', (e) => {
                 if (e.target.closest('.leaderboard-list')) return;
                const touch = e.touches[0];
                const deltaY = Math.abs(touch.clientY - overlayTouchStartY);
                if (deltaY > 20) {
                    overlayScrolling = true;
                }
            }, { passive: true });

            overlay.addEventListener('touchend', (e) => {
                if (!overlayScrolling && !e.target.closest('.tab-nav, .theme-selector, #restartButton, #submitScoreButton, .player-setup, .leaderboard-list')) {
                    const deltaTime = Date.now() - overlayTouchStartTime;
                    if (deltaTime < 250) handleOverlayClick(e);
                }
                overlayScrolling = false;
            }, { passive: false });
        });
    }

    function setupPlayerInputs() {
        playerNameInput.addEventListener('input', (e) => {
            playerName = e.target.value.slice(0, 20);
            savePlayerData();
        });
        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation(); e.preventDefault();
                document.querySelectorAll('.avatar-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedAvatar = option.dataset.avatar;
                savePlayerData();
            });
        });
    }

    async function handleSubmitScore(e) {
        e.stopPropagation(); e.preventDefault();
        if (scoreSubmitted || !playerName.trim()) return;
        submitScoreButton.disabled = true;
        submitScoreButton.textContent = 'Submitting...';
        const success = await submitScore(playerName, score, selectedAvatar);
        if (success) {
            scoreSubmitted = true;
            submitScoreButton.textContent = 'Score Submitted!';
            setTimeout(() => { loadLeaderboard(gameOverLeaderboard); }, 500);
        } else {
            submitScoreButton.disabled = false;
            submitScoreButton.textContent = 'Retry Submit';
        }
    }

    function handleOverlayClick(event) {
        // Prevent clicks on interactive elements inside tabs from triggering game start
        if (event.target.closest('.tab-nav, .tab-panel > *, #restartButton, #submitScoreButton')) return;

        event.preventDefault(); event.stopPropagation();
        
        if (!startOverlay.classList.contains('hidden')) {
            if (!isGameStarted && !isGameOver) {
                if (!playerName.trim()) {
                    playerNameInput.focus();
                    return;
                }
                startGame();
            } else if (isGamePaused) {
                resumeGame();
            }
        } else if (!gameOverlay.classList.contains('hidden')) {
            startGame();
        }
    }

    // --- NEW: Unified and Direct Input Handler ---
    function handlePointerMove(event) {
        if (isAnimatingGameOver || !isGameStarted || isGameOver || isGamePaused) return;

        // On desktop, move on hover. On mobile, only move when screen is touched.
        if (isMobile() && event.buttons === 0) return;

        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        
        // Translate screen coordinates to logical canvas coordinates, respecting aspect ratio
        let x, y;
        const arCanvas = canvas.width / canvas.height;
        const arClient = rect.width / rect.height;

        if (arClient > arCanvas) { // Letterbox top/bottom
            const scale = rect.height / canvas.height;
            const offsetX = (rect.width - canvas.width * scale) / 2;
            x = (event.clientX - rect.left - offsetX) / scale;
            y = (event.clientY - rect.top) / scale;
        } else { // Letterbox left/right
            const scale = rect.width / canvas.width;
            const offsetY = (rect.height - canvas.height * scale) / 2;
            x = (event.clientX - rect.left) / scale;
            y = (event.clientY - rect.top - offsetY) / scale;
        }

        lightcat.x = Math.max(GAME_CONFIG.CAT_RADIUS, Math.min(GAME_CONFIG.LOGICAL_WIDTH - GAME_CONFIG.CAT_RADIUS, x));
        lightcat.y = Math.max(GAME_CONFIG.CAT_RADIUS, Math.min(GAME_CONFIG.LOGICAL_HEIGHT - GAME_CONFIG.CAT_RADIUS, y));
    }
   
    function handleKeyDown(event) { 
        if ((isGameOver || isGamePaused) && (event.code === 'Space' || event.code === 'Enter')) { 
            if (isGamePaused) resumeGame(); else startGame();
            event.preventDefault(); 
        }
    }

    // --- Screen & Game State Management ---
    function showStartScreen() { 
        startOverlay.classList.remove('hidden'); 
        gameOverlay.classList.add('hidden'); 
        themeMenuBtn.classList.add('hidden');
        isGamePaused = false;
        gameContainer.classList.remove('game-active-cursor');
        
        lightcat.x = GAME_CONFIG.LOGICAL_WIDTH / 2; 
        lightcat.y = GAME_CONFIG.LOGICAL_HEIGHT / 2 - (GAME_CONFIG.LOGICAL_HEIGHT * 0.1); 
        updateDarkcatPosition(); 
        draw(); 
    }
    
    // --- SIMPLIFIED PAUSE SYSTEM ---
    function pauseGame() {
        if (!isGameStarted || isGameOver || isAnimatingGameOver || isGamePaused) return;
        
        cancelAnimationFrame(animationFrameId);
        isGamePaused = true;
        
        // Pause chain timer
        if (chainResetTimer && chainTimerStartTime > 0) {
            const elapsed = performance.now() - chainTimerStartTime;
            chainTimerDuration = Math.max(0, GAME_CONFIG.CHAIN_RESET_THRESHOLD_MS - elapsed);
            clearTimeout(chainResetTimer);
            chainTimerWasPaused = true;
        }
        
        startOverlay.classList.remove('hidden');
        themeMenuBtn.classList.add('hidden');
        gameContainer.classList.remove('game-active-cursor');
    }
    
    function resumeGame() {
        if (!isGamePaused) return;
        
        // Resume chain timer
        if (chainTimerWasPaused && chainTimerDuration > 0) {
            chainTimerStartTime = performance.now();
            chainTimerWasPaused = false;
            chainResetTimer = setTimeout(() => {
                if (!isGameOver && !isAnimatingGameOver && !isGamePaused) chainMultiplier = 1;
            }, chainTimerDuration);
        }
        
        startOverlay.classList.add('hidden'); 
        themeMenuBtn.classList.remove('hidden');
        if (!isMobile()) gameContainer.classList.add('game-active-cursor');
        isGamePaused = false;
        
        lastFrameTime = performance.now();
        deltaAccumulator = 0;
        gameLoop();
    }
    
    function startGame() {
        playerName = playerNameInput.value.trim();
        if (!playerName) { playerNameInput.focus(); return; }
        savePlayerData();

        cancelAnimationFrame(animationFrameId); 
        startOverlay.classList.add('hidden'); 
        gameOverlay.classList.add('hidden'); 
        themeMenuBtn.classList.remove('hidden');
        sessionHighMessage.classList.add('hidden'); 
        allTimeHighMessage.classList.add('hidden'); 
        if (!isMobile()) gameContainer.classList.add('game-active-cursor');
        
        isGameOver = isGameStarted = true; isAnimatingGameOver = isGamePaused = scoreSubmitted = false;
        isGameStarted = true; isGameOver = false;

        score = 0; chainMultiplier = 1; highestChainInGame = 0; nodesAbsorbedCount = 0;
        foods.length = 0; barriers.length = 0; 
        barriersEnabled = false; barrierWarningShown = false;
        lastFoodSpawnTime = performance.now(); 
        currentSpawnInterval = GAME_CONFIG.FOOD_SPAWN_INTERVAL_MS;
        startTime = performance.now(); 
        gameDuration = 0; 
        clearTimeout(chainResetTimer); 

        lightcat.x = GAME_CONFIG.LOGICAL_WIDTH / 2; 
        lightcat.y = GAME_CONFIG.LOGICAL_HEIGHT / 2 - (GAME_CONFIG.LOGICAL_HEIGHT * 0.1);
        
        lastFrameTime = performance.now();
        deltaAccumulator = 0;
        gameLoop();
    }
    
    function triggerGameOverAnimation(collidingCat) { 
        if (isAnimatingGameOver) return; 
        isAnimatingGameOver = true; 
        gameOverAnimationStartTime = performance.now(); 
        gameOverAnimationInfo.x = collidingCat.x; 
        gameOverAnimationInfo.y = collidingCat.y; 
        themeMenuBtn.classList.add('hidden');
        clearTimeout(chainResetTimer); 
        setTimeout(() => { 
            isGameOver = true; 
            isAnimatingGameOver = false; 
        }, 1000); 
    }
    
    function gameLoop(currentTime = 0) { 
        if (isGameOver) { 
            showGameOverScreen(); return; 
        } 
        if (isGamePaused) return;
        
        const deltaTime = currentTime - lastFrameTime;
        deltaAccumulator += deltaTime;
        
        while (deltaAccumulator >= FRAME_TIME) {
            if (isGameStarted && !isAnimatingGameOver) { 
                update(currentTime); 
            }
            deltaAccumulator -= FRAME_TIME;
        }
        
        draw();
        lastFrameTime = currentTime;
        animationFrameId = requestAnimationFrame(gameLoop); 
    }
    
    function showGameOverScreen() {
        cancelAnimationFrame(animationFrameId); 
        gameOverlay.classList.remove('hidden'); 
        themeMenuBtn.classList.add('hidden');
        gameContainer.classList.remove('game-active-cursor');
        finalScoreSpan.textContent = score; 
        highestChainValSpan.textContent = highestChainInGame; 
        nodesAbsorbedSpan.textContent = nodesAbsorbedCount; 
        timeSurvivedSpan.textContent = `${gameDuration}s`;
        
        if (score > 0 && playerName.trim() && supabase) {
            submitScoreButton.classList.remove('hidden');
            submitScoreButton.disabled = false;
            submitScoreButton.textContent = 'Submit to Leaderboard';
        } else {
            submitScoreButton.classList.add('hidden');
        }

        if (score > sessionHighScore) { sessionHighScore = score; sessionHighMessage.classList.remove('hidden'); }
        if (score > allTimeHighScore) { allTimeHighScore = score; allTimeHighMessage.classList.remove('hidden'); saveAllTimeHighScore(); }
        sessionHighScoreValSpan.textContent = sessionHighScore; 
        allTimeHighScoreValSpan.textContent = allTimeHighScore;
        createThemeSelector();
        loadLeaderboard(gameOverLeaderboard);
    }
    
    // --- Core Game Logic ---
    function update(currentTime) {
        updateDarkcatPosition();
        gameDuration = Math.floor((currentTime - startTime) / 1000); 
        barrierBlinkPhase = (currentTime / 500) % 1;
        
        // Input is now handled directly by events, so no position updates here.
        
        if (currentTime - lastFoodSpawnTime > currentSpawnInterval) { 
            spawnFood(); 
            lastFoodSpawnTime = currentTime; 
            currentSpawnInterval = Math.max(GAME_CONFIG.MIN_FOOD_SPAWN_INTERVAL_MS, GAME_CONFIG.FOOD_SPAWN_INTERVAL_MS - (score * (GAME_CONFIG.FOOD_SPAWN_INTERVAL_DECREMENT_PER_SCORE / 100)) ); 
        }
        
        if (currentTime - lastFoodAbsorbedTime > GAME_CONFIG.CHAIN_RESET_THRESHOLD_MS && chainMultiplier > 1) { 
            chainMultiplier = 1; clearTimeout(chainResetTimer); 
        }
        
        if (score >= GAME_CONFIG.SCORE_FOR_BARRIERS - 40 && !barrierWarningShown && !barriersEnabled) {
            showBarrierWarning();
        }
        
        if (score >= GAME_CONFIG.SCORE_FOR_BARRIERS && !barriersEnabled) { 
            barriersEnabled = true; spawnBarriers(GAME_CONFIG.INITIAL_BARRIER_COUNT); 
        } else if (barriersEnabled && barriers.length < GAME_CONFIG.MAX_BARRIER_COUNT) {
            const nextBarrierScore = GAME_CONFIG.SCORE_FOR_BARRIERS + (barriers.length * GAME_CONFIG.BARRIER_INCREMENT_SCORE);
            if (score >= nextBarrierScore) spawnBarriers(1);
        }
        
        for (let i = foods.length - 1; i >= 0; i--) { 
            const food = foods[i]; 
            if (food.type === 'light') { 
                if (checkCircleCollision(lightcat, food)) { absorbFood(lightcat); foods.splice(i, 1); continue; } 
                if (checkCircleCollision(darkcat, food)) { triggerGameOverAnimation(darkcat); return; } 
            } else if (food.type === 'dark') { 
                if (checkCircleCollision(darkcat, food)) { absorbFood(darkcat); foods.splice(i, 1); continue; } 
                if (checkCircleCollision(lightcat, food)) { triggerGameOverAnimation(lightcat); return; } 
            } 
        }
        
        for (const b of barriers) { 
            if (checkLineCircleCollision(b, lightcat)) { triggerGameOverAnimation(lightcat); return; } 
            if (checkLineCircleCollision(b, darkcat)) { triggerGameOverAnimation(darkcat); return; } 
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        const theme = themes[currentTheme];
        
        if (barriers.length > 0) { 
            const blinkIntensity = Math.sin(barrierBlinkPhase * Math.PI * 2) * 0.5 + 0.5; 
            ctx.strokeStyle = blendColors(theme['--barrier-color'], theme['--light-color'], blinkIntensity); 
            ctx.lineWidth = GAME_CONFIG.BARRIER_LINE_WIDTH; 
            for (const b of barriers) { ctx.beginPath(); ctx.moveTo(b.x1, b.y1); ctx.lineTo(b.x2, b.y2); ctx.stroke(); } 
        }
        
        for (const f of foods) {
            if (f.isDark) {
                ctx.fillStyle = f.color; ctx.strokeStyle = theme['--light-color']; ctx.lineWidth = Math.max(3, f.radius * 0.2);
                ctx.beginPath(); ctx.arc(f.x, f.y, f.radius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                ctx.shadowColor = theme['--light-color']; ctx.shadowBlur = f.radius * 0.5;
                ctx.beginPath(); ctx.arc(f.x, f.y, f.radius * 0.7, 0, 2 * Math.PI); ctx.fill(); ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = f.color; ctx.shadowColor = f.color; ctx.shadowBlur = f.radius * 0.3;
                ctx.beginPath(); ctx.arc(f.x, f.y, f.radius, 0, 2 * Math.PI); ctx.fill(); ctx.shadowBlur = 0;
            }
        }
        
        updateParticles(); drawParticles();
        drawVectorAnimal(darkcat, selectedAvatar, true);
        drawVectorAnimal(lightcat, selectedAvatar, false);
        
        // --- FIXED: HUD Drawing Logic ---
        if (isGameStarted && !isGameOver && !isAnimatingGameOver && !isGamePaused) {
            // Always update the HTML HUD. CSS will handle its visibility based on screen size.
            hudScore.textContent = `SCORE:${String(score).padStart(6, '0')}`;
            hudChain.textContent = `CHAIN:x${chainMultiplier}`;

            // On larger screens (where CSS hides the HTML HUD), draw the score on the canvas.
            if (window.matchMedia('(min-width: 48rem)').matches) {
                ctx.fillStyle = theme['--light-color'];
                ctx.font = `${GAME_CONFIG.HUD_FONT_SIZE}px "Press Start 2P"`;
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE:${String(score).padStart(6, '0')}`, GAME_CONFIG.HUD_MARGIN_X, GAME_CONFIG.HUD_MARGIN_Y);
                ctx.textAlign = 'right';
                ctx.fillText(`CHAIN:x${chainMultiplier}`, GAME_CONFIG.LOGICAL_WIDTH - GAME_CONFIG.HUD_MARGIN_X, GAME_CONFIG.HUD_MARGIN_Y);
            }
        }
        
        if (isAnimatingGameOver) { 
            const elapsed = performance.now() - gameOverAnimationStartTime, progress = Math.min(elapsed / 1000, 1), alpha = Math.abs(Math.sin(progress * Math.PI * 4)); 
            ctx.fillStyle = `${theme['--barrier-color']}60`; 
            ctx.strokeStyle = `${theme['--light-color']}${Math.round(alpha*255).toString(16).padStart(2, '0')}`; 
            ctx.lineWidth = 5; 
            ctx.beginPath(); 
            ctx.arc(gameOverAnimationInfo.x, gameOverAnimationInfo.y, GAME_CONFIG.GAME_OVER_EXPLOSION_RADIUS * progress, 0, 2 * Math.PI); 
            ctx.fill(); ctx.stroke(); 
        }
    }

    function createParticle(x, y, type) {
        for (let i=0; i < 8; i++) { // Less particles per event for performance
             particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                life: 1.0, decay: Math.random() * 0.02 + 0.02,
                type, size: Math.random() * 4 + 2
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= p.decay; p.vx *= 0.98; p.vy *= 0.98;
            if (p.life <= 0) {
                particles[i] = particles[particles.length - 1]; // Swap with last
                particles.pop(); // and pop
            }
        }
    }

    function drawParticles() {
        const theme = themes[currentTheme];
        for (const p of particles) {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.type === 'food' ? theme['--barrier-color'] : theme['--light-color'];
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }

    function drawVectorAnimal(animal, type, isDark) {
        const { x, y, radius } = animal; const theme = themes[currentTheme];
        ctx.save(); ctx.translate(x, y);
        const fillColor = isDark ? theme['--bg-color'] : theme['--light-color'];
        const accentColor = isDark ? theme['--light-color'] : theme['--bg-color'];
        switch(type) {
            case 'cat': drawVectorCat(radius, fillColor, accentColor); break;
            case 'dog': drawVectorDog(radius, fillColor, accentColor); break;
            case 'monkey': drawVectorMonkey(radius, fillColor, accentColor); break;
            case 'dino': drawVectorDino(radius, fillColor, accentColor); break;
            case 'bear': drawVectorBear(radius, fillColor, accentColor); break;
        }
        ctx.restore();
    }
    function drawVectorCat(radius, fillColor, accentColor) { /* ... (Vector art functions are unchanged) ... */ const s=radius/100;ctx.lineWidth=s*4;ctx.lineCap='round';ctx.lineJoin='round';ctx.fillStyle=fillColor;ctx.strokeStyle=accentColor;ctx.beginPath();ctx.moveTo(s*-30,s*-35);ctx.quadraticCurveTo(s*-25,s*-45,s*-30,s*-50);ctx.quadraticCurveTo(s*-60,s*-70,s*-50,s*-35);ctx.arc(0,0,s*70,Math.PI+(Math.PI/4),Math.PI*2-(Math.PI/4));ctx.quadraticCurveTo(s*60,s*-70,s*30,s*-50);ctx.quadraticCurveTo(s*25,s*-45,s*30,s*-35);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle=accentColor;ctx.beginPath();ctx.ellipse(s*-20,s*-15,s*8,s*12,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(s*20,s*-15,s*8,s*12,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.moveTo(s*0,s*0);ctx.quadraticCurveTo(s*-5,s*-5,s*0,s*-10);ctx.quadraticCurveTo(s*5,s*-5,s*0,s*0);ctx.closePath();ctx.fill();ctx.beginPath();ctx.moveTo(s*0,s*-40);ctx.quadraticCurveTo(s*-5,s*-45,s*0,s*-50);ctx.quadraticCurveTo(s*5,s*-45,s*0,s*-40);ctx.closePath();ctx.fill();ctx.fillStyle=fillColor;ctx.beginPath();ctx.ellipse(s*-18,s*-18,s*2,s*3,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(s*22,s*-18,s*2,s*3,0,0,Math.PI*2);ctx.fill();ctx.strokeStyle=accentColor;ctx.beginPath();ctx.moveTo(s*0,s*5);ctx.quadraticCurveTo(s*-10,s*15,s*-15,s*10);ctx.stroke();ctx.beginPath();ctx.moveTo(s*0,s*5);ctx.quadraticCurveTo(s*10,s*15,s*15,s*10);ctx.stroke();ctx.beginPath();ctx.moveTo(s*-70,s*-5);ctx.lineTo(s*-35,s*0);ctx.stroke();ctx.beginPath();ctx.moveTo(s*-70,s*5);ctx.lineTo(s*-35,s*5);ctx.stroke();ctx.beginPath();ctx.moveTo(s*-70,s*15);ctx.lineTo(s*-35,s*10);ctx.stroke();ctx.beginPath();ctx.moveTo(s*70,s*-5);ctx.lineTo(s*35,s*0);ctx.stroke();ctx.beginPath();ctx.moveTo(s*70,s*5);ctx.lineTo(s*35,s*5);ctx.stroke();ctx.beginPath();ctx.moveTo(s*70,s*15);ctx.lineTo(s*35,s*10);ctx.stroke();}
    function drawVectorDog(radius, fillColor, accentColor) { /* ... */ const s=radius/100;ctx.lineWidth=s*6;ctx.lineCap='round';ctx.lineJoin='round';ctx.fillStyle=fillColor;ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(0,0,s*60,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(s*-70,s*-20);ctx.bezierCurveTo(s*-80,s*-40,s*-80,s*-60,s*-65,s*-65);ctx.bezierCurveTo(s*-50,s*-70,s*-40,s*-50,s*-45,s*-30);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(s*70,s*-20);ctx.bezierCurveTo(s*80,s*-40,s*80,s*-60,s*65,s*-65);ctx.bezierCurveTo(s*50,s*-70,s*40,s*-50,s*45,s*-30);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle=accentColor;ctx.beginPath();ctx.arc(s*-20,s*-10,s*8,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(s*20,s*-10,s*8,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(0,s*10,s*8,s*10,0,0,Math.PI*2);ctx.fill();ctx.strokeStyle=accentColor;ctx.beginPath();ctx.moveTo(0,s*25);ctx.bezierCurveTo(s*-10,s*35,s*-25,s*30,s*-25,s*25);ctx.stroke();ctx.beginPath();ctx.moveTo(0,s*25);ctx.bezierCurveTo(s*10,s*35,s*25,s*30,s*25,s*25);ctx.stroke();}
    function drawVectorMonkey(radius, fillColor, accentColor) { /* ... */ const s=radius/100;ctx.lineWidth=s*6;ctx.lineCap='round';ctx.lineJoin='round';ctx.fillStyle=fillColor;ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(s*-70,0,s*30,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(s*70,0,s*30,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,0,s*55,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle=accentColor;ctx.beginPath();ctx.arc(s*-20,s*-10,s*8,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(s*20,s*-10,s*8,0,Math.PI*2);ctx.fill();ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(0,s*15,s*20,0.2,Math.PI-0.2);ctx.stroke();}
    function drawVectorDino(radius, fillColor, accentColor) { /* ... */ const s=radius/100;ctx.lineWidth=s*6;ctx.lineCap='round';ctx.lineJoin='round';ctx.fillStyle=fillColor;ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(0,s*10,s*60,Math.PI*0.8,Math.PI*2.2);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(s*-30,s*-60);ctx.lineTo(s*-40,s*-75);ctx.lineTo(s*-50,s*-60);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(s*0,s*-70);ctx.lineTo(s*0,s*-85);ctx.lineTo(s*10,s*-70);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(s*30,s*-60);ctx.lineTo(s*40,s*-75);ctx.lineTo(s*50,s*-60);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle=accentColor;ctx.beginPath();ctx.arc(s*-25,0,s*10,0,Math.PI*2);ctx.fill();ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(s*20,s*35,s*25,0.2,Math.PI-0.2);ctx.stroke();}
    function drawVectorBear(radius, fillColor, accentColor) { /* ... */ const s=radius/100;ctx.lineWidth=s*7;ctx.lineCap='round';ctx.lineJoin='round';ctx.fillStyle=fillColor;ctx.strokeStyle=accentColor;ctx.beginPath();ctx.arc(0,0,s*65,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(s*-50,s*-50,s*25,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(s*50,s*-50,s*25,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.ellipse(0,s*15,s*30,s*25,0,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle=accentColor;ctx.beginPath();ctx.arc(s*-25,s*-15,s*7,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(s*25,s*-15,s*7,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(0,s*10,s*12,s*8,0,0,Math.PI*2);ctx.fill();}

    function blendColors(c1, c2, ratio) { 
        if (!c1||!c2||typeof c1!=='string'||typeof c2!=='string') return c1||c2||'#ffffff';
        const F=(h)=>parseInt(h,16),T=(d)=>d.toString(16).padStart(2,'0'); 
        const R1=F(c1.slice(1,3)),G1=F(c1.slice(3,5)),B1=F(c1.slice(5,7)); 
        const R2=F(c2.slice(1,3)),G2=F(c2.slice(3,5)),B2=F(c2.slice(5,7)); 
        const R=Math.round(R1+(R2-R1)*ratio),G=Math.round(G1+(G2-G1)*ratio),B=Math.round(B1+(B2-B1)*ratio); 
        return `#${T(R)}${T(G)}${T(B)}`; 
    }
    
    function updateDarkcatPosition() { 
        darkcat.x = GAME_CONFIG.LOGICAL_WIDTH - lightcat.x; 
        darkcat.y = GAME_CONFIG.LOGICAL_HEIGHT - lightcat.y; 
    }
    
    function spawnFood() {
        const type = Math.random() < 0.5 ? 'light' : 'dark';
        const theme = themes[currentTheme];
        const color = (type === 'light') ? theme['--light-color'] : theme['--bg-color'];
        let attempts = 0, x, y, lightDist, darkDist;
        do {
            x = Math.random() * (GAME_CONFIG.LOGICAL_WIDTH - 2 * GAME_CONFIG.FOOD_RADIUS) + GAME_CONFIG.FOOD_RADIUS;
            y = Math.random() * (GAME_CONFIG.LOGICAL_HEIGHT - 2 * GAME_CONFIG.FOOD_RADIUS) + GAME_CONFIG.FOOD_RADIUS;
            if (++attempts >= 50) { lastFoodSpawnTime += 500; return; }
            lightDist = Math.sqrt((x - lightcat.x)**2 + (y - lightcat.y)**2);
            darkDist = Math.sqrt((x - darkcat.x)**2 + (y - darkcat.y)**2);
        } while (isPositionInsideBarrier(x, y, GAME_CONFIG.FOOD_RADIUS) || 
                 lightDist <= GAME_CONFIG.SAFE_DISTANCE_FROM_CATS || darkDist <= GAME_CONFIG.SAFE_DISTANCE_FROM_CATS);
        
        foods.push({ x, y, radius: GAME_CONFIG.FOOD_RADIUS, type, color, isDark: type === 'dark' });
    }
    
    function spawnBarriers(count) { 
        for (let i = 0; i < count; i++) { 
            let attempts = 0, valid = false, x1, y1, x2, y2; 
            while (!valid && attempts++ < 50) { 
                const minL = GAME_CONFIG.BARRIER_MIN_LENGTH;
                const maxL = Math.min(GAME_CONFIG.LOGICAL_WIDTH, GAME_CONFIG.LOGICAL_HEIGHT) * GAME_CONFIG.BARRIER_MAX_LENGTH_FACTOR; 
                const padding = GAME_CONFIG.CAT_RADIUS * 2 + 20; 
                if (Math.random() < 0.5) { 
                    y1 = y2 = Math.random()*(GAME_CONFIG.LOGICAL_HEIGHT - 2*padding) + padding; 
                    x1 = Math.random()*(GAME_CONFIG.LOGICAL_WIDTH - minL - 2*padding) + padding; 
                    x2 = x1 + Math.random()*(maxL - minL) + minL; 
                } else { 
                    x1 = x2 = Math.random()*(GAME_CONFIG.LOGICAL_WIDTH - 2*padding) + padding; 
                    y1 = Math.random()*(GAME_CONFIG.LOGICAL_HEIGHT - minL - 2*padding) + padding; 
                    y2 = y1 + Math.random()*(maxL - minL) + minL; 
                } 
                if (!isLineTooCloseToCats(x1, y1, x2, y2)) { valid = true; barriers.push({x1, y1, x2, y2}); } 
            } 
        } 
    }
    function isPositionInsideBarrier(px, py, r) { 
        for(const b of barriers) if (checkLineCircleCollision(b, {x: px, y: py, radius: r})) return true; 
        return false; 
    }
    
    function absorbFood(collidingCat) { 
        createParticle(collidingCat.x, collidingCat.y, 'food');
        nodesAbsorbedCount++; 
        lastFoodAbsorbedTime = performance.now(); 
        clearTimeout(chainResetTimer); 
        chainMultiplier++; 
        if (chainMultiplier > highestChainInGame) highestChainInGame = chainMultiplier; 
        score += GAME_CONFIG.SCORE_PER_FOOD * chainMultiplier; 
        
        chainTimerStartTime = performance.now();
        chainTimerDuration = GAME_CONFIG.CHAIN_RESET_THRESHOLD_MS;
        chainTimerWasPaused = false;
        chainResetTimer = setTimeout(() => {
            if (!isGameOver && !isAnimatingGameOver && !isGamePaused && !chainTimerWasPaused) chainMultiplier = 1;
        }, chainTimerDuration);
    }
    function loadHighScores() { 
        try { const s=localStorage.getItem(LOCAL_STORAGE_KEY_ALL_TIME_HIGH); if(s) allTimeHighScore=parseInt(s,10); } catch(e) { console.error(e); } 
        sessionHighScore = 0; 
    }
    function saveAllTimeHighScore() { 
        try { localStorage.setItem(LOCAL_STORAGE_KEY_ALL_TIME_HIGH, allTimeHighScore.toString()); } catch(e) { console.error(e); } 
    }
    
    window.onload = init;
</script>

</body>
</html>
